"""Test MultiScaleFractionalGenerator"""

import numpy as np
import pytest
from scipy import stats

from StatTools.analysis.dpcca import dpcca
from StatTools.generators.multi_scale_fractional_generator import (
    MultiScaleFractionalGenerator,
)


def test_generate_creates_series():
    """Test different series generated by generate() method"""
    gen = MultiScaleFractionalGenerator(h_list=[0.8, 2.2], crossover_points=[2**3])
    length = 2**10
    series = gen.generate(length=length, n_tracks=1, seed=123)

    assert isinstance(series, np.ndarray)
    assert series.shape == (1, length)
    assert gen._pos == 0
    assert gen._series is not None

    series = gen.generate(length=length, n_tracks=10, seed=123)

    assert isinstance(series, np.ndarray)
    assert series.shape == (10, length)
    assert gen._pos == 0
    assert gen._series is not None


def test_generate_two_h():
    """Test generation with two asymptotes"""
    h_list = [0.8, 2.2]
    gen = MultiScaleFractionalGenerator(h_list, crossover_points=[2**3])
    length = 2**16
    n_tracks = 3
    signals = gen.generate(length, n_tracks)
    s_list = 2 ** np.arange(3, int(np.log2(length)) + 1)
    step = 0.5
    threads = 4
    _, _, f1, s1 = dpcca(signals, 2, step, s_list, processes=threads, n_integral=1)
    ffunc = np.transpose(f1, (1, 2, 0))
    se = []
    for i in range(ffunc.shape[0]):
        for j in range(ffunc.shape[1]):
            if i != j:
                continue
            log_s = np.log(s1)[0:3]
            log_f = np.log(np.sqrt(ffunc[i, j, :]))[0:3]
            res = stats.linregress(log_s, log_f)
            se.append((h_list[1] - res.slope) ** 2)

            log_s = np.log(s1)[8:]
            log_f = np.log(np.sqrt(ffunc[i, j, :]))[8:]
            res = stats.linregress(log_s, log_f)
            se.append((h_list[0] - res.slope) ** 2)
    assert np.mean(se) == pytest.approx(0, abs=0.05)


def test_impulse_response():
    """Test the impulse response calculation"""
    h_list = [0.8, 2.2]
    crossover_points = [2**8]
    length = 2**16
    # multi version
    segments = []
    prev_value = None
    edges = [1] + [c + 1 for c in crossover_points] + [length + 1]

    for i, h in enumerate(h_list):
        start = edges[-2 - i]
        end = edges[-1 - i]

        s = np.arange(start, end)
        k_i = (h - 0.5) * (s ** (h - 1.5))

        if prev_value is None:
            prev_value = k_i
        else:
            k_prev = prev_value / prev_value[0] * k_i[-1]
            segments.append(k_prev)
            prev_value = k_i
    segments = [k_i] + segments
    impulse_response = np.concatenate(segments)

    # hand 2h version
    K1 = (h_list[1] - 0.5) * (
        np.arange(1, crossover_points[0] + 1) ** (h_list[1] - 1.5)
    )
    K0 = (h_list[0] - 0.5) * (
        np.arange(crossover_points[0] + 1, length + 1) ** (h_list[0] - 1.5)
    )

    K0 = K0 / K0[0] * K1[-1]
    segments = (K1, K0)
    impulse_response_test = np.concatenate(segments)
    assert np.equal(impulse_response, impulse_response_test).all()


def test_stop_iteration():
    """Test StopIteration"""
    gen = MultiScaleFractionalGenerator(h_list=[0.8, 2.2], crossover_points=[2**3])
    gen.generate(length=2**10, n_tracks=1, seed=1)

    for _ in range(2**10):
        next(gen)

    with pytest.raises(StopIteration):
        next(gen)


def test_multi_channel():
    """Test output shape of multi-channel generation"""
    gen = MultiScaleFractionalGenerator(h_list=[0.8, 2.2], crossover_points=[2**3])
    series = gen.generate(length=2**10, n_tracks=3, seed=99)

    assert series.shape == (3, 2**10)
    x0 = next(gen)
    assert x0.shape == (3,)


def test_regenerate_resets_series_and_position():
    """Checking that the Re-generation should overwrite the series and reset the pos"""
    gen = MultiScaleFractionalGenerator(h_list=[0.8, 2.2], crossover_points=[2**3])
    first = gen.generate(length=2**10, n_tracks=1, seed=1)
    next(gen)
    second = gen.generate(length=2**10, n_tracks=1, seed=2)

    assert not np.allclose(first, second)  # different series
    assert gen._pos == 0
    assert gen._series is not None

    val = next(gen)
    assert np.allclose(val, second[:, 0])  # first value from the second series
